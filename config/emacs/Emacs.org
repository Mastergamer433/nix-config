#+title MG433's Emacs configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el

* General Configuration
** User Interface
Clean up Emacs' user interface, I like it being more minimal.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room
  (menu-bar-mode -1)          ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)
#+end_src

Improve scrolling
#+begin_src emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed nil
        mouse-wheel-follow-mouse 't
        scroll-step 1
        use-dialog-box nil)
#+end_src

Enable line numbers, but disable it for some modes.
#+begin_src emacs-lisp
  ;; Disable line numbers for some modes.
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  treemacs-mode-hook
                  shell-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  ;; Line Numbers.
  (column-number-mode)
  (global-display-line-numbers-mode t)
#+end_src

Make the cursor highlighted.

#+begin_src emacs-lisp
  ;; Highlight cursor line.
  (global-hl-line-mode t)
#+end_src

Don’t warn for large files (shows up when launching videos)
#+begin_src emacs-lisp
  (setq large-file-warning-threshold nil)
#+end_src

Don’t warn for following symlinked files

#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src
Don’t warn when advice is added for functions

#+begin_src emacs-lisp
  (setq ad-redefinition-action 'accept)
#+end_src

** Theme
I like a bounch of themes but right now i like dracula most.
#+begin_src emacs-lisp
  (use-package doom-themes)
  (use-package spacegray-theme)
  (load-theme 'doom-dracula t)
#+end_src

** Font
*** Set the font
#+begin_src emacs-lisp
;; Set the font
(set-face-attribute 'default nil :font "Fira Code" :height 110)

;; Set the fixed pitch face
(set-face-attribute 'fixed-pitch nil :font "Fira Code" :height 100)

;; Set the variable pitch face
(set-face-attribute 'variable-pitch nil :font "Fira Code" :height 120 :weight 'regular)
#+end_src

*** All the icons
Now I don't know if this should be in font or modeline cause I am only using it in the modeline but it is fonts so.
This is what makes the modeline look nice(a circle as the state instead of <N> <I> and so on).
#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src
*** Emojis in buffers
Sometime i'd like emacs to show emojis in buffers.
#+begin_src emacs-lisp
  (use-package emojify)
#+end_src

** Mode Line
*** Basic Customization
#+begin_src emacs-lisp
  (setq display-time-format "%l:%M %p %b %d"
      display-time-load-average-threshold 0.0)
#+end_src

*** Doom Modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 30)))
#+end_src

** Workspaces
I like having workspaces in emacs, so I dont have to have multiple emacs instance and all that headache.
#+begin_src emacs-lisp
  (use-package perspective
    :demand t
    :bind (("C-M-k" . persp-switch)
           ("C-M-n" . persp-next)
           ("C-x k" . persp-kill-buffer*))
    :custom
    (persp-initial-frame-name "Main")
    (persp-mode-prefix-key (kbd "C-c C-p"))
    :config
    ;; Running `persp-mode' multiple times resets the perspective list...
    (unless (equal persp-mode t)
      (persp-mode)))
#+end_src

** Notifications
Alert is a great library for showing notifications from other packages in a variety of ways.

#+begin_src emacs-lisp
  (use-package alert
    :commands alert
    :config
    (setq alert-default-style 'notifications))
#+end_src

** Displaying World Time
display-time-world command provides a nice display of the time at a specified list od timezones.
#+begin_src emacs-lisp
  (setq display-time-world-list
        '(("Etc/UTC" "UTC")
          ("Europe/Stockholm" "Stockholm")
          ("America/Los_Angeles" "Seattle")
          ("America/Denver" "Denver")
          ("America/New_York" "New York")
          ("Pacific/Auckland" "Auckland")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Kolkata" "Hyderabad")))
  (setq display-time-world-time-format "%a, %d %b %I:%M %p %Z")
#+end_src

* Completion System
** Preserve Minibuffer History with savehist-mode
#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))
#+end_src

** Completions with vertico
#+begin_src emacs-lisp
  (defun keo/minibuffer-backward-kill (arg)
    (interactive "p")
    (cond
     ;; When minibuffer has ~/
     ((and minibuffer-completing-file-name
           (string= (minibuffer-contents-no-properties) "~/"))
      (delete-minibuffer-contents)
      (insert "/home/"))

     ;; When minibuffer has some file and folder names
     ((and minibuffer-completing-file-name
           (not (string= (minibuffer-contents-no-properties) "/"))
           (= (preceding-char) ?/))
      (delete-char (- arg))
      (zap-up-to-char (- arg) ?/))

     ;; All other cases
     (t
      (delete-char (- arg)))))

  (use-package vertico
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                ("C-f" . vertico-exit)
                :map minibuffer-local-map
                ("M-h" . backward-kill-word)
                ("" . keo/minibuffer-backward-kill))
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode))
#+end_src

** Completions in Regions with Corfu
#+begin_src emacs-lisp
  ;; Enable Corfu completion UI
  ;; See the Corfu README for more configuration tips.
  (use-package corfu
    :bind (("TAB" . corfu-insert))
    :custom
    (corfu-auto t)
    (corfu-echo-documentation nil)
    :init
    (global-corfu-mode))

  ;; Disable auto completion-at-point for some modes.
  (dolist (mode '(term-mode-hook
                  shell-mode-hook
                  eshell-mode-hook
                  lsp-mode-hook))
    (add-hook mode (lambda () (setq-local corfu-auto nil))))

  ;; Add extensions
  (use-package cape
    ;; Bind dedicated completion commands
    ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    :bind (("C-c c p" . completion-at-point) ;; capf
           ("C-c c t" . complete-tag)        ;; etags
           ("C-c c d" . cape-dabbrev)        ;; or dabbrev-completion
           ("C-c c h" . cape-history)
           ("C-c c f" . cape-file)
           ("C-c c k" . cape-keyword)
           ("C-c c s" . cape-symbol)
           ("C-c c a" . cape-abbrev)
           ("C-c c i" . cape-ispell)
           ("C-c c l" . cape-line)
           ("C-c c w" . cape-dict)
           ("C-c c \\" . cape-tex)
           ("C-c c _" . cape-tex)
           ("C-c c ^" . cape-tex)
           ("C-c c &" . cape-sgml)
           ("C-c c r" . cape-rfc1345))
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    ;;(add-to-list 'completion-at-point-functions #'cape-history)
    ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
    ;;(add-to-list 'completion-at-point-functions #'cape-tex)
    ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
    ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
    ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
    ;;(add-to-list 'completion-at-point-functions #'cape-ispell)
    ;;(add-to-list 'completion-at-point-functions #'cape-dict)
    ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
    ;;(add-to-list 'completion-at-point-functions #'cape-line)
    )
#+end_src
** Consult Commands
#+begin_src emacs-lisp
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("C-s" . consult-line)
           ("C-S-s" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key (kbd "M-.")
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    (autoload 'projectile-project-root "projectile")
    (setq consult-project-function (lambda (_) (projectile-project-root)))
  )
#+end_src

** Improved Candidate Filtering with Orderless
#+begin_src emacs-lisp
  ;; Optionally use the `orderless' completion style.
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Completion Annotations with Marginalia
#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+end_src

** Completion Actions with Embark
#+begin_src emacs-lisp
  (defun sudo-find-file (file)
    "Open FILE as root."
    (interactive "FOpen file as root: ")
    (when (file-writable-p file)
      (user-error "File is user writeable, aborting sudo"))
    (find-file (if (file-remote-p file)
                   (concat "/" (file-remote-p file 'method) ":"
                           (file-remote-p file 'user) "@" (file-remote-p file 'host)
                           "|sudo:root@"
                           (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                 (concat "/sudo:root@localhost:" file))))

  (defun with-minibuffer-keymap (keymap)
    (lambda (fn &rest args)
      (minibuffer-with-setup-hook
          (lambda ()
            (use-local-map
             (make-composed-keymap keymap (current-local-map))))
        (apply fn args))))

  (defvar embark-completing-read-prompter-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "<tab>") 'abort-recursive-edit)
      map))

  (advice-add 'embark-completing-read-prompter :around
              (with-minibuffer-keymap embark-completing-read-prompter-map))
  ;;(define-key vertico-map (kbd "<tab>") 'embark-act-with-completing-read)

  (defun embark-act-with-completing-read (&optional arg)
    (interactive "P")
    (let* ((embark-prompter 'embark-completing-read-prompter)
           (act (propertize "Act" 'face 'highlight))
           (embark-indicator (lambda (_keymap targets) nil)))
      (embark-act arg)))

  (eval-when-compile
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn)))))))

  (eval-when-compile
    (defmacro my/embark-split-action (fn split-type)
      `(defun ,(intern (concat "my/embark-"
                               (symbol-name fn)
                               "-"
                               (car (last  (split-string
                                            (symbol-name split-type) "-"))))) ()
         (interactive)
         (funcall #',split-type)
         (call-interactively #',fn))))


  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
   
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

  (define-key embark-file-map     (kbd "o") (my/embark-ace-action find-file))
  (define-key embark-buffer-map   (kbd "o") (my/embark-ace-action switch-to-buffer))
  (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump))

  (define-key embark-file-map     (kbd "2") (my/embark-split-action find-file split-window-below))
  (define-key embark-buffer-map   (kbd "2") (my/embark-split-action switch-to-buffer split-window-below))
  (define-key embark-bookmark-map (kbd "2") (my/embark-split-action bookmark-jump split-window-below))

  (define-key embark-file-map     (kbd "3") (my/embark-split-action find-file split-window-right))
  (define-key embark-buffer-map   (kbd "3") (my/embark-split-action switch-to-buffer split-window-right))
  (define-key embark-bookmark-map (kbd "3") (my/embark-split-action bookmark-jump split-window-right))
  (define-key embark-file-map     (kbd "S") 'sudo-find-file)
#+end_src

* Window Management
** Dynamic Window Management with edwina
#+begin_src emacs-lisp
  (use-package edwina
    :config
    (setq display-buffer-base-action '(display-buffer-below-selected))
    (edwina-setup-dwm-keys)
    (edwina-mode 1))
#+end_src

** Window Selection with ace-window
#+begin_src emacs-lisp
  (use-package ace-window
    :bind (("M-o" . ace-window))
    :custom
    (aw-scope 'frame)
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (aw-minibuffer-flag t)
    :config
    (ace-window-display-mode 1))
#+end_src

** Window History with winner-mode
#+begin_src emacs-lisp
  (use-package winner
    :ensure nil
    :after evil
    :config
    (winner-mode)
    (define-key evil-window-map "u" 'winner-undo)
    (define-key evil-window-map "U" 'winner-redo))
#+end_src

* Variables
** WM
#+begin_src emacs-lisp
  (setq window-manager-wallpaper-path "~/.wallpapers/nixos.png")
#+end_src

* Keep Folders Clean
#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))


  ;; auto-save-mode doesn't create the path automatically!
  (make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)

  (setq auto-save-list-file-prefix (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory)
        auto-save-file-name-transforms `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))

  (setq create-lockfiles nil)

  (setq projectile-known-projects-file (expand-file-name "tmp/projectile-bookmarks.eld" user-emacs-directory)
        lsp-session-file (expand-file-name "tmp/.lsp-session-v1" user-emacs-directory))

  (use-package no-littering)
#+end_src

* Development
** Git
Magit
#+begin_src emacs-lisp
  (use-package magit
    :bind ("C-M-;" . magit-status)
    :commands (magit-status magit-get-current-branch)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

Magit todos
#+begin_src emacs-lisp
  (use-package magit-todos)
#+end_src

Projectile
#+begin_src emacs-lisp
  (defun dw/switch-project-action ()
    "Switch to a workspace with the project name and start `magit-status'."
    ;; TODO: Switch to EXWM workspace 1?
    (persp-switch (projectile-project-name))
    (magit-status))

  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :demand t
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    (when (file-directory-p "~/Projects")
      (setq projectile-project-search-path '("~/Projects")))
    (setq projectile-switch-project-action #'dw/switch-project-action))

  (use-package counsel-projectile
    :after projectile
    :bind (("C-M-p" . counsel-projectile-find-file))
    :config
    (counsel-projectile-mode))
#+end_src

** Languages
*** Language server support with eglot
#+begin_src emacs-lisp
  (use-package eglot
    :bind (:map eglot-mode-map
                ("C-c C-a" . eglot-code-actions)
                ("C-c C-r" . eglot-rename))
    :config
    (setq eglot-autoshutdown t
          eglot-confirm-server-initiated-edits nil)
    (add-to-list 'eglot-server-programs
                 '((js2-mode typescript-mode) . ("typescript-language-server" "--stdio"))))
#+end_src

*** Debug Adapter Support
#+begin_src emacs-lisp
  (use-package dap-mode)
#+end_src

*** Meta Lisp
#+begin_src emacs-lisp
  (use-package lispy
    :hook ((emacs-lisp-mode . lispy-mode)
           (scheme-mode . lispy-mode)))

  (use-package lispyville
    :hook ((lispy-mode . lispyville-mode))
    :config
    (lispyville-set-key-theme '(operators c-w additional
                                          additional-movement slurp/barf-cp
                                          prettify)))
#+end_src

*** Emacs Lisp
#+begin_src emacs-lisp
  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . helpful-function)
    ([remap describe-symbol] . helpful-symbol)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key))

  (use-package highlight-defined
    :hook (emacs-lisp-mode . highlight-defined-mode))

  (use-package elmacro
    :hook (emacs-lisp-mode . elmacro-mode))

  (use-package suggest
    :hook (emacs-lisp-mode . suggest-mode))

  (use-package easy-escape
    :hooks ((emacs-lisp-mode . easy-escape-minor-mode)
            (lisp-mode       . easy-escape-minor-mode)))
#+end_src

*** Common Lisp
#+begin_src emacs-lisp
  (use-package slime
    :config
    (setq inferior-lisp-program "sbcl"))
#+end_src

*** Scheme
#+begin_src emacs-lisp
  (use-package geiser)
  (use-package geiser-guile)
#+end_src

*** TypeScript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2)
    (require 'dap-node))
#+end_src

*** Nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")
#+end_src

*** Haskell
#+begin_src emacs-lisp
    (use-package haskell-mode
      :mode "\\.hs\\'"
)
#+end_src

*** Rust
#+begin_src emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'"
    :hook (rust-mode . lsp-deferred))
#+end_src

*** Lua
#+begin_src emacs-lisp
  (use-package lua-mode
    :mode "\\.lua\\'"
    :hook (lua-mode . lsp-deferred))
#+end_src

*** Fennel
#+begin_src emacs-lisp
  (use-package fennel-mode
    :mode "\\.fnl\\'")
#+end_src
** Snippets with yasnippet
#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (setq yas-snippet-dirs '("~/emacs/snippets"))
    (yas-global-mode 0))

  (use-package tempel
    ;; Require trigger prefix before template name when completing.
    ;; :custom
    ;; (tempel-trigger-prefix "<")

    :bind (("M-+" . tempel-expand) ;; Alternative tempel-expand
           ("M-*" . tempel-insert))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
                  (cons #'tempel-expand
                        completion-at-point-functions)))

    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)
    (add-hook 'emacs-lisp-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    (global-tempel-abbrev-mode)
  )
  (use-package tempel-collection)

#+end_src

** Simple HTTPD
#+begin_src emacs-lisp
  (use-package simple-httpd)
#+end_src

* Applications
** Mail
#+begin_src emacs-lisp
  (use-package mu4e
    :ensure nil
    :config

    ;; This is set to 't' to avoid mail syncing issues when using mbsync
    (setq mu4e-change-filenames-when-moving t)

    ;; Refresh mail using isync every 10 minutes
    (setq mu4e-update-interval (* 10 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-maildir "~/Mail")
    (setq mu4e-completing-read-function #'completing-read)
    (setq mu4e-change-filenames-when-moving t)

    (setq mu4e-contexts
          (list
           (make-mu4e-context
            :name "Private"
            :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address . "mg433@kimane.se")
                    (user-full-name    . "Karl Elis Odenhage")
                    (mu4e-drafts-folder  . "/Drafts")
                    (mu4e-sent-folder  . "/Sent Mail")
                    (mu4e-refile-folder  . "/All Mail")
                    (mu4e-trash-folder  . "/Trash")
                    (smtpmail-smtp-server . "mail.kimane.se")
                    (smtpmail-smtp-service . 465)
                    (smtpmail-stream-type . ssl)))))

    (defun remove-nth-element (nth list)
      (if (zerop nth) (cdr list)
        (let ((last (nthcdr (1- nth) list)))
          (setcdr last (cddr last))
          list)))
    (setq mu4e-marks (remove-nth-element 5 mu4e-marks))
    (add-to-list 'mu4e-marks
                 '(trash
                   :char ("d" . "▼")
                   :prompt "dtrash"
                   :dyn-target (lambda (target msg) (mu4e-get-trash-folder msg))
                   :action (lambda (docid msg target)
                             (mu4e~proc-move docid
                                             (mu4e~mark-check-target target) "-N"))))

    (setq message-send-mail-function 'smtpmail-send-it)
    (setq mu4e-compose-signature "- mg433")

    (setq message-kill-buffer-on-exit t)

    ;; Display options
    (setq mu4e-view-show-images t)
    (setq mu4e-view-show-addresses 't)

    ;; Composing mail
    (setq mu4e-compose-dont-reply-to-self t)

    ;; Use mu4e for sending e-mail
    (setq mail-user-agent 'mu4e-user-agent)

    (setq mu4e-maildir-shortcuts
          '(("/Inbox"     . ?i)
            ("/Sent Mail" . ?s)
            ("/Trash"     . ?t)
            ("/Drafts"    . ?d)
            ("/All Mail"  . ?a))))

  (setq keo/mu4e-inbox-query
        "maildir:/Inbox AND flag:unread")

  (defun keo/go-to-inbox ()
    (interactive)
    (mu4e-headers-search dw/mu4e-inbox-query))

  (use-package mu4e-alert
    :after mu4e
    :config
    ;; Show unread emails from all inboxes
    (setq mu4e-alert-interesting-mail-query dw/mu4e-inbox-query)

    ;; Show notifications for mails already notified
    (setq mu4e-alert-notify-repeated-mails nil)

    (mu4e-alert-enable-notifications))

  (use-package org-mime
    :bind
    ("C-<return>" . org-mime-htmlize))
#+end_src

** Media
*** mpv
#+begin_src emacs-lisp
  (use-package mpv)
#+end_src
*** Controlling
#+begin_src emacs-lisp
  (use-package playerctl)
#+end_src

** Chatting
*** ERC
I like IRC so I wanna use ERC an IRC client for Emacs.
#+begin_src emacs-lisp
  (use-package erc
    :ensure nil
    :config

    )
  (keo/leader-keys
    "e" '(:ignore t :which-key "ERC")
    "ej" '(lambda () (interactive)
            (insert "/join #") :which-key "Join")
    "eq" '(lambda () (interactive)
            (insert "/quit")
            (erc-send-current-line) :which-key "Quit"))
#+end_src

** Mastodon
#+begin_src emacs-lisp
  (use-package mastodon
    :config
    (setq mastodon-instance-url "https://emacs.ch"
          mastodon-active-user "Mastergamer433")
    (mastodon-discover))
#+end_src

** Firefox
#+begin_src emacs-lisp
  (use-package edit-server
    :config
    (setq edit-server-new-frame t)
    :init
    (edit-server-start))
#+end_src

** Password Manager
#+begin_src emacs-lisp
  (use-package password-store)

  (use-package auth-source
    :config
    (setq auth-source '(password-store)))
#+end_src

** Gemini
#+begin_src emacs-lisp
  (use-package elpher)
#+end_src

** Matrix
#+begin_src emacs-lisp
  (use-package ement)
#+end_src

* File Management
** Dired
#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom ((dired-listing-switches "-agho --group-directories-first"))
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))

  (keo/leader-keys
    "d"   '(:ignore t :which-key "dired")
    "dd"  '(dired :which-key "Here")
    "dh"  '((lambda () (interactive) (dired "~")) :which-key "Home")
    "dn"  '((lambda () (interactive) (dired "~/Notes")) :which-key "Notes")
    "do"  '((lambda () (interactive) (dired "~/Downloads")) :which-key "Downloads")
    "d."  '((lambda () (interactive) (dired "~/.dotfiles")) :which-key "dotfiles")
    "de"  '((lambda () (interactive) (dired "~/.dotfiles/config/emacs")) :which-key ".emacs.d"))
#+end_src

** Dired Single
#+begin_src emacs-lisp
  (use-package dired-single)
#+end_src

** Dired Icons
#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

** Move to trash instead of deleting.
#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash t)
#+end_src

* Denote
#+begin_src emacs-lisp
  (use-package denote
    :config
    (setq denote-directory "~/Notes/")
    (setq denote-known-keywords '("journal" "projects" "ideas")))
#+end_src

* Org mode
** Basic configuration
#+begin_src emacs-lisp
  (defun keo/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Fira Code" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

  (defun keo/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    :hook (org-mode . keo/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")

    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    (setq org-agenda-files
          '("~/OrgFiles/Calendar.org"))

    (setq org-image-actual-width nil)

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)

    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
            (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))
    (keo/org-font-setup))

  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

  (defun keo/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . keo/org-mode-visual-fill))

  (setq org-startup-folded t)

#+end_src

*Guix Packages*
#+begin_src scheme :noweb-ref packages :noweb-sep "\n"
  "emacs-org"
  "emacs-org-bullets"
  "emacs-visual-fill-column"
#+end_src

** Configure Babel Languages

#+begin_src emacs-lisp

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)))

#+end_src

** Auto-tangle configuration files
#+begin_src emacs-lisp

    ;; Automatically tangle our Emacs.org config file when we save it
    (defun keo/org-babel-tangle-config ()
      (when (string-equal (file-name-directory (buffer-file-name))
                          (expand-file-name "~/.dotfiles/"))
        ;; Dynamic scoping to the rescue
        (let ((org-confirm-babel-evaluate nil))
          (org-babel-tangle))))

    (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'keo/org-babel-tangle-config)))

#+end_src

** Org Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-directory "~/Notes")
    (org-roam-completion-everywhere t)
    (org-roam-capture-templates
     '(("d" "default" plain
        "%?"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
        :unnarrowed t)
       ("l" "programming language" plain
        "* Characteristics\n\n- Family: %?\n- Inspired by: \n\n* Reference\n\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date: %U\n\n")
        :unnarrowed t)
       ("b" "book notes" plain
        (file "~/Notes/Templates/BookNoteTemplate.org")
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
        :unnarrowed t)
       ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Project")
        :unnarrowed t)
       ))
    (org-roam-dailies-capture-templates
     '(("d" "default" entry "* %<%H:%M>: %?"
        :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n\n"))
       ("t" "Task" entry
        #'org-roam-capture--get-point
        "* TODO %?\n  %U\n  %a\n  %i"
        :file-name "Journal/%<%Y-%m-%d>"
        :olp ("Tasks")
        :empty-lines 1
        :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")))
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           :map org-mode-map
           ("C-M-i" . completion-at-point)
           :map org-roam-dailies-map
           ("Y" . org-roam-dailies-capture-yesterday)
           ("T" . org-roam-dailies-capture-tomorrow))
    :bind-keymap
    ("C-c n d" . org-roam-dailies-map)
    :config
    (require 'org-roam-dailies) ;; Ensure the keymap is available
    (org-roam-db-autosync-mode)
    (org-roam-setup))
#+end_src

*Guix Packages*
#+begin_src scheme :noweb-ref packages :noweb-sep "\n"
  "emacs-org-roam"
#+end_src

** Org Present
#+begin_src emacs-lisp
  (use-package org-tree-slide
    :after org
    :config
    (define-key org-tree-slide-mode-map (kbd "<f5>") 'org-tree-slide-move-previous-tree)
    (define-key org-tree-slide-mode-map (kbd "<f6>") 'org-tree-slide-move-next-tree))
  (global-set-key (kbd "<f8>") 'org-tree-slide-mode)
  (global-set-key (kbd "S-<f8>") 'org-tree-slide-skip-done-toggle)
#+end_src

*Guix Packages*
#+begin_src scheme :noweb-ref packages :noweb-sep "\n"
  "emacs-org-tree-slide"
#+end_src

** Org CalDav
#+begin_src emacs-lisp
      (use-package org-caldav
        :init
        (setq org-caldav-url 'google
              org-caldav-clendar-id "88d59157cbf81579069338800a049a251ceb2bbbaa0704ab124ccec464c839ba@group.calendar.google.com"
              org-caldav-inbox "~/OrgFiles/Calendar.org"
              org-icalendar-timezone "Europe/Stockholm"))
#+end_src

* Keyboard keybinds
** Which key
#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0))
#+end_src

** Hydra
#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

** Evil
#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** General
#+begin_src emacs-lisp
    (use-package general
    :config
    (general-create-definer keo/exwm-keyboard
      :keymaps '(normal insert visual emacs)
      :prefix "s"
      :global-prefix "s")
    (general-create-definer keo/leader-keys
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-SPC"))
#+end_src

** General leader key
#+begin_src emacs-lisp
  (keo/leader-keys
    "b" '(:ignore t :which-key "Buffer")
    "bs" '(consult-buffer :which-key "Switch Buffer")
    "fd" '(:ignore t :which-key "dotfiles")
    "fde" '((lambda () (interactive) (find-file "~/.dotfiles/config/emacs/Emacs.org")))
    "p" '(:ignore t :which-key "Pass")
    "pp" '(password-store-copy :which-key "Copy")
    "pn" '(password-store-insert :which-key "New")
    "pg" '(password-store-generate :which-key "Generate"))
#+end_src

* Libs
** Mysql
#+begin_src emacs-lisp
  (use-package emacsql-mysql)
#+end_src

** Playerctl
#+begin_src emacs-lisp
  (use-package playerctl
    :bind(("C-c C-SPC" . playerctl-play-pause-song)
          ("C-c C-n" . playerctl-next-song)
          ("C-c C-p" . playerctl-previous-song)
          ("C-c C-f" . playerctl-seek-forward)
          ("C-c C-b" . playerctl-seek-backward)))
#+end_src

** Request.el
#+begin_src emacs-lisp
  (use-package request)
#+end_src

** S
#+begin_src emacs-lisp
  (use-package s)
#+end_src

** ht
#+begin_src emacs-lisp
  (use-package ht)
#+end_src

** ov
#+begin_src emacs-lisp
  (use-package ov)
#+end_src

** websocket
#+begin_src emacs-lisp
  (use-package websocket)
#+end_src

** ts
#+begin_src emacs-lisp
  (use-package ts)
#+end_src

** f
#+begin_src emacs-lisp
  (use-package f)
#+end_src

** jeison
#+begin_src emacs-lisp
  (use-package jeison)
#+end_src

* Databases
#+begin_src emacs-lisp
  (setq emacs-db (emacsql-mysql "harry_potter_emacs" :user "harry_potter_emacs"
                                :password ""
                                :host "192.168.21.228"))
  (setq awesomewm-db (emacsql-mysql "harry_potter_awesomewm" :user "harry_potter_awesomewm"
                                    :password ""
                                    :host "192.168.21.228"))
#+end_src

* My own Emacs functions
** Find File Mysql
#+begin_src emacs-lisp
  (defun uuid-create ()
    "Return a newly generated UUID. This uses a simple hashing of variable data."
    (let ((s (md5 (format "%s%s%s%s%s%s%s%s%s%s"
                          (user-uid)
                          (emacs-pid)
                          (system-name)
                          (user-full-name)
                          user-mail-address
                          (current-time)
                          (emacs-uptime)
                          (garbage-collect)
                          (random)
                          (recent-keys)))))
      (format "%s-%s-3%s-%s-%s"
              (substring s 0 8)
              (substring s 8 12)
              (substring s 13 16)
              (substring s 16 20)
              (substring s 20 32))))

  (defun find-file-mysql ()
      (emacsql emacs-db [:insert :into files
                         :values ([$s1 $s2 $s3])]
              (uuid-create) (buffer-file-name) (s-trim (shell-command-to-string "date --rfc-email"))))

  (add-hook 'find-file-hook 'find-file-mysql)
#+end_src

** WM
*** Window rules
#+begin_src emacs-lisp
  (setq window-rules
        '(("Emacs Dired" . (("instance" . "Emacs-Dired")
                            ("class" . "Emacs")
                            ("floating" . "true")))
          ("Discord" . (("class" . "discord")
                        ("tag" . "chat")))
          ("firefox" . (("class" . "firefox")
                        ("tag" . "www")))))

  (defun keo/wm-window-rules ()
    (s-join
     "\n"
     (mapcar
      (lambda (rule)
        (format
         "herbstclient rule %s"
         (s-join
          " "
          (mapcar
           (lambda (arg)
             (format
              "%s=%s"
              (car arg)
              (cdr arg)))
           (cdr rule)))))
      window-rules)))
  (keo/wm-window-rules)
#+end_src

*** Goto workspace
#+begin_src emacs-lisp
  (defun keo/wm-goto-workspace (workspace)
    (shell-command-to-string (format "herbstclient use %s" workspace)))
#+end_src

*** Search Youtube
#+begin_src emacs-lisp
  (defun keo/wm-search-youtube ()
    (let ((search (keo/wm-ask '() "Search")))
      (browse-url (s-trim (format "https://www.youtube.com/results?search_query=%s" (string-replace " " "+" search))))
      (keo/wm-goto-workspace "www")))
#+end_src

*** Search Google
#+begin_src emacs-lisp
  (defun keo/wm-search-google ()
    (let ((search (keo/wm-ask '() "Search")))
      (browse-url (s-trim (format "https://www.google.com/search?q=%s" (string-replace " " "+" search))))
      (keo/wm-goto-workspace "www")))
#+end_src

*** Open Github Repo
#+begin_src emacs-lisp
  (defun keo/wm-open-github-repo (&optional prompt-for-everything)
    (let* ((owner (keo/wm-ask '() (if prompt-for-everything "Repo Owner" "Repo")))
           (user (when prompt-for-everything (keo/wm-ask '() "Repo Name")))
           (path (mapconcat 'identity `(,owner ,user) "/")))
      (browse-url (format "https://github.com/%s" path))
      (keo/wm-goto-workspace "www")))
#+end_src

*** Get all clients
#+begin_src emacs-lisp
  (defun keo/wm-get-all-clients ()
    (string-split
     (s-trim
      (shell-command-to-string "herbstclient attr clients | grep 0x"))))
#+end_src

*** Get title of client
#+begin_src emacs-lisp
  (defun keo/wm-get-title-of-client (client)
    (s-trim
     (shell-command-to-string (format "herbstclient attr clients.%s | grep title | cut -d'\"' -f2" client))))
#+end_src

*** Get class of client
#+begin_src emacs-lisp
  (defun keo/wm-get-class-of-client (client)
    (s-trim
     (shell-command-to-string (format "herbstclient attr clients.%s | grep class | cut -d'\"' -f2" client))))
#+end_src

*** Get title of all clients
#+begin_src emacs-lisp
  (defun keo/wm-get-title-of-all-clients ()
    (let ((titles (list))
          (clients (keo/wm-get-all-clients)))
      (mapcar 
       (lambda (c)
         (push (s-trim (keo/wm-get-title-of-client c)) titles))
       clients)
      titles))
#+end_src

*** Get id by name
#+begin_src emacs-lisp
  (defun keo/wm-get-client-by-name (name)
    (let ((client "")
          (clients (keo/wm-get-all-clients)))
      (mapcar 
       (lambda (c)
         (if (equal name (keo/wm-get-title-of-client c))
             (setq client c)))
       clients)
      client))
#+end_src

*** Get id by class
#+begin_src emacs-lisp
  (defun keo/wm-get-client-by-class (class)
    (let ((client "")
          (clients (keo/wm-get-all-clients)))
      (mapcar 
       (lambda (c)
         (if (equal class (keo/wm-get-class-of-client c))
             (setq client c)))
       clients)
      client))
#+end_src

*** Get class by name
#+begin_src emacs-lisp
  (defun keo/wm-get-client-class-by-name (name)
    (let ((client (keo/wm-get-client-by-name name)))
      (s-trim (shell-command-to-string (format "herbstclient attr clients.%s | grep class | cut -d'\"' -f2" client)))))
#+end_src

*** Goto window by class
#+begin_src emacs-lisp
  (defun keo/wm-goto-window-by-class (class)
    (let* ((client (keo/wm-get-client-by-class class)))
      (if client
          (shell-command-to-string (format "herbstclient jumpto %s" (s-left (- (length client) 1) client))))))
#+end_src

*** Switch Window
#+begin_src emacs-lisp
  (defun keo/wm-switch-window ()
    (let* ((names (keo/wm-get-title-of-all-clients))
           (choices (list))
           (format-choice-function (lambda (name)
                             (push
                              (format
                               "%s: %s"
                               (keo/wm-get-client-class-by-name
                                name)
                               name)
                              choices)))
           (client (keo/wm-get-client-by-name
                    (s-trim-left
                     (cadr
                      (s-split
                       ":"
                       (s-chomp
                        (keo/wm-ask
                         (let ((choices (list)))
                           (mapcar format-choice-function names)
                           choices)
                         "Window"))))))))
      (shell-command-to-string
       (format
        "herbstclient jumpto %s"
        (s-left
         (- (length client) 1)
         client)))))
#+end_src

*** Ask
#+begin_src emacs-lisp
  (defun keo/wm-ask (choices &optional prompt)
    (s-trim (shell-command-to-string
     (format
      "echo \"%s\" | rofi -dmenu -p \"%s\""
      (string-join choices "\n") prompt))))
#+end_src

*** Open config
#+begin_src emacs-lisp
  (setq keo/configs `(("emacs" . ("~/.dotfiles/config/emacs/Emacs.org"))
                      ("herbstluft" . ("~/.dotfiles/config/herbstluftwm/autostart"))
                      ("fish" . (,(format "~/.dotfiles/hosts/%s/default.nix" (system-name)) ,9))))

  (defun keo/wm-open-config (config)
    (select-frame
     (make-frame
      '((name . "Emacs-Config"))))
    (find-file
     (cadr (assoc config keo/configs)))
    (let ((line (caddr
                  (assoc config keo/configs)))
          (regex (cadddr
                   (assoc config keo/configs))))
      (if line (goto-line line))
      (if regex
          (progn
            (beginning-of-buffer)
            (search-forward-regexp regex))))
    (delete-other-windows))
#+end_src

*** Open dired
#+begin_src emacs-lisp
  (setq keo/dirs `(("home" . "~/")
                   ("dotfiles" . "~/.dotfiles/")
                   ("downloads" . "~/Downloads/")
                   ("projects" . "~/Projects/")))

  (defun keo/wm-open-dired (dir)
    (select-frame
     (make-frame
      '((name . "Emacs-Dired"))))
    (dired
     (cdr (assoc dir keo/dirs)))
    (delete-other-windows))
#+end_src

*** Open Project
#+begin_src emacs-lisp
  (defun keo/wm-open-project ()
    (select-frame
     (make-frame
      '((name . "Project"))))
    (projectile-switch-project-by-name
     (keo/wm-ask projectile-known-projects "Project"))
    (delete-other-windows))
#+end_src

*** Denote new note
#+begin_src emacs-lisp
  (defun keo/wm-denote-new-note ()
    (select-frame (make-frame '((name . "New-Note"))))
    (call-interactively 'denote-subdirectory)
    (delete-other-windows))
#+end_src

*** Wallpaper
#+begin_src emacs-lisp
  (defun keo/wm-wallpaper ()
    window-manager-wallpaper-path)
#+end_src

** Mail count
#+begin_src emacs-lisp
  (defun keo/mail-count (max-count)
    (if keo/mu4e-inbox-query
      (let* ((mail-count (shell-command-to-string
                           (format "mu find --nocolor -n %s \"%s\" | wc -l" max-count keo/mu4e-inbox-query))))
        (format " %s" (string-trim mail-count)))
      ""))
#+end_src

** Proxmox
#+begin_src emacs-lisp

  (defvar proxmox-base-url "https://proxmox.kimane.se/api2/json")

  (defun proxmox-get-vms ()
    (interactive)
    (defvar vms)
    (request (format "%s/nodes/pve/qemu" proxmox-base-url)
      :headers `(("Authorization" . ,(format "PVEAPIToken=%s" (password-store-get "proxmox/api"))))
      :parser (lambda () (buffer-string))
      :success (cl-function
                (lambda (&key data &allow-other-keys)
                  (setq vms data))))
    vms)

  (defun proxmox-get-vm-by-name (name)
    (let* ((vms (jeison-read t (proxmox-get-vms) "data"))
           (VM (list)))
      (mapcar
       (lambda (vm)
         (if (equal name (jeison-read t vm "name"))
             (setq VM vm)))
       vms)
      VM))

  (defun proxmox-get-vm-by-name (vmid)
    (let* ((vms (jeison-read t (proxmox-get-vms) "data"))
           (VM (list)))
      (mapcar
       (lambda (vm)
         (if (equal vmid (jeison-read t vm "vmid"))
             (setq VM vm)))
       vms)
      VM))

  (defun proxmox-get-vm-names ()
    (let* ((vms (jeison-read t (proxmox-get-vms) "data")))
      (mapcar
       (lambda (vm)
         (jeison-read t vm "name"))
       vms)))

  (defun proxmox-select-a-vm ()
    (proxmox-get-vm-by-name (completing-read "VM: " (proxmox-get-vm-names))))

  (defun proxmox-clone-vm ()
    (interactive)
    (let* ((vmid (jeison-read t (proxmox-select-a-vm) "vmid")))
      (request (format "%s/nodes/pve/qemu/%s/clone" proxmox-base-url vmid)
        :type "POST"
        :headers `(("Authorization" . ,(format "PVEAPIToken=%s" (password-store-get "proxmox/api"))))
        :params `(("full" . "1") ("newid" . ,(completing-read "New vm's id: " ())) ("name" . ,(completing-read "New vm's name: " ())))
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (message "I sent: %S" (assoc-default 'form data)))))
      vmid))

  (defun proxmox-power-off-vm (&optional vmid)
    (interactive)
    (let* ((vmid (if vmid vmid (jeison-read t (proxmox-select-a-vm) "vmid"))))
      (request (format "%s/nodes/pve/qemu/%s/status/stop" proxmox-base-url vmid)
        :type "POST"
        :headers `(("Authorization" . ,(format "PVEAPIToken=%s" (password-store-get "proxmox/api"))))
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (message "I sent: %S" (assoc-default 'form data)))))))

  (defun proxmox-power-on-vm (&optional vmid)
    (interactive)
    (let* ((vmid (if vmid vmid (jeison-read t (proxmox-select-a-vm) "vmid"))))
      (request (format "%s/nodes/pve/qemu/%s/status/start" proxmox-base-url vmid)
        :type "POST"
        :headers `(("Authorization" . ,(format "PVEAPIToken=%s" (password-store-get "proxmox/api"))))
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (message "I sent: %S" (assoc-default 'form data)))))))

  (defun proxmox-restart-vm (&optional vmid)
    (interactive)
    (let* ((vmid (if vmid vmid (jeison-read t (proxmox-select-a-vm) "vmid"))))
      (request (format "%s/nodes/pve/qemu/%s/status/reboot" proxmox-base-url vmid)
        :type "POST"
        :headers `(("Authorization" . ,(format "PVEAPIToken=%s" (password-store-get "proxmox/api"))))
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (message "I sent: %S" (assoc-default 'form data)))))))

  (defun proxmox-get-ip (vmid)
    (defvar ifs)
    (defvar IF)
    (defvar IP)
    (request (format "%s/nodes/pve/qemu/%s/agent/network-get-interfaces" proxmox-base-url vmid)
      :headers `(("Authorization" . ,(format "PVEAPIToken=%s" (password-store-get "proxmox/api"))))
      :parser (lambda () (buffer-string))
      :success (cl-function
                (lambda (&key data &allow-other-keys)
                  (setq ifs data))))
    (mapcar
     (lambda (if)
       (if (equal "eth0" (jeison-read t if "name"))
           (setq IF if)))
     (jeison-read t (jeison-read t ifs "data") "result"))

    (mapcar
     (lambda (ip)
       (if (equal "ipv4" (jeison-read t ip "ip-address-type"))
           (setq IP (jeison-read t ip "ip-address"))))
     (jeison-read t IF "ip-addresses"))
    IP)

  (proxmox-get-ip "3000")
  (proxmox-restart-vm)
  (proxmox-get-vm-by-name "proxy.kimane.se")
#+end_src

** pfSense
#+begin_src emacs-lisp
  (setq shell-file-name "bash")
  (setq pfsense-base-url "https://pfsense.kimane.se:9123/fauxapi/v1/?action=")

  (defun pfsense-fauxapi-auth (fauxapi_apikey fauxapi_apisecret)
    (setq fauxapi_timestamp
          (s-trim
           (shell-command-to-string
            "date -u +%Y%m%dZ%H%M%S")))
    (setq fauxapi_nonce
          (s-trim
           (shell-command-to-string
            "head -c 40 /dev/urandom | (md5sum 2>/dev/null  || md5 2>/dev/null) | head -c 8")))
    (setq fauxapi_hash
          (s-trim
           (shell-command-to-string
            (format
             "echo -n %s%s%s | (sha256sum 2>/dev/null  || shasum -a 256 2>/dev/null) | cut -d' ' -f1"
             fauxapi_apisecret
             fauxapi_timestamp
             fauxapi_nonce))))
    (setq fauxapi_auth
          (format
           "%s:%s:%s:%s"
           fauxapi_apikey
           fauxapi_timestamp
           fauxapi_nonce
           fauxapi_hash))
    fauxapi_auth)

  (defun pfsense-gateway-status ()
    (defvar status)
    (request
      (format
       "%sgateway_status"
       pfsense-base-url)
      :headers `(("fauxapi-auth" . ,(pfsense-fauxapi-auth
                                     "PFFAMy4j8IuCv5VYsJFcsfQj"
                                     "rWLYcZtv7WfmevCWegzswr09AZp1so1Zi83v8vyP7ycGiQQzXPuW0Gyfv4ym")))
      :success (cl-function
                (lambda (&key data &allow-other-keys)
                  (setq status
                        (jeison-read t data "data")))))
    status)

  (defun pfsense-firewall-nat-new (source-if dest-ip dest-port)
    (defvar rules)
    (request
      (format
       "%sconfig_get"
       pfsense-base-url)
      :headers `(("fauxapi-auth" . ,(pfsense-fauxapi-auth
                                     "PFFAMy4j8IuCv5VYsJFcsfQj"
                                     "rWLYcZtv7WfmevCWegzswr09AZp1so1Zi83v8vyP7ycGiQQzXPuW0Gyfv4ym")))
      :success (cl-function
                (lambda (&key data &allow-other-keys)
                  (message "%s"
                           (jeison-read t (jeison-read t (jeison-read t data "data") "config") "nat")))))
    rules)
#+end_src

** Org agenda
I wanna have a function to open org agenda in a new frame with another instance name som my window manager can manage the placement of the window.
#+begin_src emacs-lisp
  (defun keo/org-agenda ()
    (select-frame (make-frame '((name . "Calendar"))))
    (org-agenda-list)
    (delete-other-windows))
#+end_src

** Open config frame
#+begin_src emacs-lisp
  (defun keo/new-config-frame ()
    (select-frame (make-frame '((name . "Config"))))
    (persp-switch "Config")
    (find-file "~/.dotfiles/config/emacs/Emacs.org")
    (split-window)
    (find-file "~/.dotfiles/config/herbstluftwm/autostart"))

#+end_src

** Awesomewm new client
#+begin_src emacs-lisp
  ;;(emacsql emacs-db [:create-table files
  ;;           ([id name date])])

  ;;(emacsql emacs-db [:drop-table files])

  (cl-defun keo/awesomewm-new-client (&key id name class)
    (emacsql awesomewm-db [:insert :into clients 
                                   :values ([$s1 $s2 $s3])]
             id name class))
  (cl-defun keo/awesomewm-remove-client (&key id)
    (emacsql awesomewm-db [:delete :from clients
                                   :where (= id $s1)]
             id))
  (cl-defun keo/awesomewm-rename-client (&key id name class)
    (emacsql awesomewm-db [:delete :from clients
                                   :where (= id $s1)]
             id)
    (emacsql awesomewm-db [:insert :into clients 
                                   :values ([$s1 $s2])]
             id name class))
#+end_src

** Awesomewm notify
#+begin_src emacs-lisp
  (cl-defun awesomewm-notify (&key title text)
    (start-process-shell-command "awesome-client" nil (format "
  awesome-client '
  naughty = require(\"naughty\")
  naughty.notify({
  title=\"%s\",
  text=\"%s\"})
  '" title text)))
  
#+end_src
